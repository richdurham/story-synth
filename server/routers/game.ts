import { z } from "zod";
import { publicProcedure, protectedProcedure, router } from "../_core/trpc";
import { getAllGameRoles, getAllGameVariables, getActiveGameIssue, getCurrentGameState, getGameIssueById, getAllGameIssues } from "../gameDb";

/**
 * Game Configuration Router
 * Provides endpoints for retrieving game configuration (roles, issues, variables)
 */
export const gameRouter = router({
  /**
   * GET /api/trpc/game.config
   * Retrieves static game configuration: roles, issues, and global variables
   */
  config: publicProcedure.query(async () => {
    const roles = await getAllGameRoles();
    const issues = await getAllGameIssues();
    const variables = await getAllGameVariables();

    return {
      roles: roles.map(r => ({
        id: r.roleId,
        name: r.name,
        description: r.description,
      })),
      issues: issues.map(i => ({
        id: i.issueId,
        title: i.title,
        type: i.type,
      })),
      variables: Object.fromEntries(
        variables.map(v => [v.variableId, v.currentValue])
      ),
    };
  }),

  /**
   * GET /api/trpc/game.state
   * Retrieves current game state: public display and role-specific private dashboards
   */
  state: publicProcedure.query(async () => {
    const currentState = await getCurrentGameState();
    const currentIssue = currentState?.currentIssueId 
      ? await getGameIssueById(currentState.currentIssueId)
      : null;
    const variables = await getAllGameVariables();

    return {
      public_display: {
        current_issue: currentIssue?.issueId || null,
        issue_title: currentIssue?.title || "No active issue",
        issue_description: currentIssue?.description || "",
        round: currentState?.round || 1,
      },
      player_dashboard: {
        variables: Object.fromEntries(
          variables.map(v => [v.variableId, v.currentValue])
        ),
        available_actions: ["Resolve Issue", "Send Note"],
      },
    };
  }),

  /**
   * POST /api/trpc/game.resolveIssue
   * Processes a player's resolution choice for the current issue
   * Triggers AI story generation and state updates
   */
  resolveIssue: protectedProcedure
    .input(
      z.object({
        issueId: z.string(),
        playerRole: z.string(),
        resolutionChoice: z.string(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      // Verify the issue exists
      const issue = await getGameIssueById(input.issueId);
      if (!issue) {
        throw new Error("Issue not found");
      }

      // For now, return a placeholder response
      // In Phase 5, this will integrate with the AI narrative generation module
      return {
        status: "success",
        narrative_outcome: "The decision has been recorded. The narrative outcome will be generated by the AI module.",
        state_changes: {},
        new_issue_id: null,
      };
    }),

  /**
   * GET /api/trpc/game.currentIssue
   * Retrieves the current active issue with full details
   */
  currentIssue: publicProcedure.query(async () => {
    const currentState = await getCurrentGameState();
    if (!currentState?.currentIssueId) {
      return null;
    }

    const issue = await getGameIssueById(currentState.currentIssueId);
    if (!issue) {
      return null;
    }

    return {
      id: issue.issueId,
      title: issue.title,
      description: issue.description,
      type: issue.type,
      round: currentState.round,
    };
  }),
});
